use crate::graph::{Object, Scope, Extension};
use std::path::{Component, Path, PathBuf};

// This code was generated by Claude

pub fn format_dependency(current_dir: &Path, dep: &str) -> (Scope, Object, Option<Extension>) {
    if dep.starts_with("./") || dep.starts_with("../") {
        let full_path = current_dir.join(dep);
        let normalized_path = normalize_path(&full_path);
        let (object, extension) = split_path_and_extension(&normalized_path);
        (Scope("app".into()), object, extension)
    } else if dep.starts_with("@/") {
        let (object, extension) = split_path_and_extension(Path::new(&dep[2..]));
        (Scope("app".into()), object, extension)
    } else {
        let scope = Scope("dep".into());
        let object = if dep.starts_with('@') {
            // For scoped packages, keep everything up to the second slash
            Object(dep.split('/').take(2).collect::<Vec<_>>().join("/"))
        } else {
            // For non-scoped packages, keep only the first part
            Object(dep.split('/').next().unwrap_or(dep).to_string())
        };
        (scope, object, None)
    }
}

fn normalize_path(path: &Path) -> PathBuf {
    let mut components = path.components().peekable();
    let mut ret = if let Some(c @ Component::Prefix(..)) = components.peek().cloned() {
        components.next();
        PathBuf::from(c.as_os_str())
    } else {
        PathBuf::new()
    };

    for component in components {
        match component {
            Component::Prefix(..) => unreachable!(),
            Component::RootDir => {
                ret.push(component.as_os_str());
            }
            Component::CurDir => {}
            Component::ParentDir => {
                ret.pop();
            }
            Component::Normal(c) => {
                ret.push(c);
            }
        }
    }
    ret
}

fn split_path_and_extension(path: &Path) -> (Object, Option<Extension>) {
    let stem = path.with_extension("").to_string_lossy().into_owned();
    let extension = path.extension().map(|s| Extension(s.to_string_lossy().into_owned()));
    (Object(stem), extension)
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    fn assert_dependency(
        current_dir: &str,
        dep: &str,
        expected_scope: &str,
        expected_object: &str,
        expected_extension: Option<&str>,
    ) {
        let dir = PathBuf::from(current_dir);
        let (scope, object, extension) = format_dependency(&dir, dep);
        assert_eq!(scope.0, expected_scope);
        assert_eq!(object.0, expected_object);
        assert_eq!(extension.map(|e| e.0), expected_extension.map(String::from));
    }

    #[test]
    fn test_relative_paths() {
        assert_dependency("mydir/app", "../lib/db.ts", "app", "mydir/lib/db", Some("ts"));
        assert_dependency("mydir/app", "./foo.ts", "app", "mydir/app/foo", Some("ts"));
        assert_dependency("mydir/app/subdir", "../../lib/db.ts", "app", "mydir/lib/db", Some("ts"));
    }

    #[test]
    fn test_module_paths() {
        assert_dependency("blah", "@/lib/db.ts", "app", "lib/db", Some("ts"));
        assert_dependency("mydir/app/subdir", "@/lib/db.ts", "app", "lib/db", Some("ts"));
    }

    #[test]
    fn test_npm_packages() {
        assert_dependency("mydir/app", "lodash", "dep", "lodash", None);
        assert_dependency("mydir/app", "lodash/foo/bar.js", "dep", "lodash", None);
        assert_dependency("mydir/app", "@types/react", "dep", "@types/react", None);
        assert_dependency("mydir/app", "@types/react/foo.js", "dep", "@types/react", None);
    }
}
